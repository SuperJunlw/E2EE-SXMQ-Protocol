/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import org.example.request.ClientHelloRequest;
import org.junit.jupiter.api.Test;

import javax.net.ssl.*;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.X509Certificate;
import java.nio.ByteBuffer;

import static org.junit.jupiter.api.Assertions.*;

class AppTest {
    static Charset CHARSET = StandardCharsets.US_ASCII;
    static int BLOCK_SIZE = 16384;

    @Test void appHasAGreeting() {
        App classUnderTest = new App();
        assertNotNull(classUnderTest.getGreeting(), "app should have a greeting");
    }

    @Test void testConnectingToSXMQServer() throws IOException, InterruptedException, NoSuchAlgorithmException, KeyStoreException, KeyManagementException {
        // Create a trust manager that does not validate certificate chains
        TrustManager[] trustAllCerts = new TrustManager[] {
                new X509TrustManager() {
                    public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                        return new X509Certificate[0];
                    }
                    public void checkClientTrusted(
                            java.security.cert.X509Certificate[] certs, String authType) {
                    }
                    public void checkServerTrusted(
                            java.security.cert.X509Certificate[] certs, String authType) {
                    }
                }
        };

        // Install the all-trusting trust manager
        SSLContext sc = SSLContext.getInstance("SSL");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        SSLSocketFactory sslSocketFactory = sc.getSocketFactory();
        //SocketFactory sslSocketFactory = SSLSocketFactory.getDefault();
        SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket("smp4.simplex.im", 5223);
        SSLParameters sslParameters = sc.getDefaultSSLParameters();;
        sslParameters.setApplicationProtocols(new String[]{"smp/1"});
        socket.setSSLParameters(sslParameters);
        InputStream in = socket.getInputStream();

        byte[] paddedServerHello = in.readNBytes(BLOCK_SIZE);
        System.out.println("paddedServerHello:");
        System.out.println(new String(paddedServerHello, CHARSET));


        byte[] mainBlockBytes = getMainBlockBytes(paddedServerHello);
        System.out.println(mainBlockBytes);
        printSmpVersions(mainBlockBytes);


        OutputStream out = socket.getOutputStream();
        byte[] clientHello = new ClientHelloRequest((short) 11).getBytes();
        System.out.println("CONNECTED? " + socket.isConnected() + ", CLOSED? " + socket.isClosed() + ", BOUNDED? " + socket.isBound() + ", IN SHUTDOWN? " + socket.isInputShutdown() + ", OUT SHUTDOWN?" + socket.isOutputShutdown());
        byte[] paddedClientHello = toPaddedString(clientHello);
        out.write(paddedClientHello);
        System.out.println("Sent clientHello.");
        byte[] paddedResponse = in.readNBytes(BLOCK_SIZE);
        System.out.println("Response to clientHello:");
        System.out.println(new String(paddedResponse, CHARSET));
        byte[] ping = "PING".getBytes(CHARSET);
        byte[] paddedPing = toPaddedString(ping);
        out.write(paddedPing);
        byte[] paddedPingResponse = in.readNBytes(BLOCK_SIZE);
        System.out.println("Response to ping:");
        System.out.println(new String(paddedPingResponse, CHARSET));
    }

    public static byte[] toPaddedString(byte[] message) {
        byte padSymbol = (byte)'#';
        if (message.length >= BLOCK_SIZE) {
            throw new RuntimeException("Message must be less than " + BLOCK_SIZE + " bytes long. Currently it is " + message.length + " bytes long.");
        }
        short originalLength = (short) message.length;
        ByteBuffer paddedString = ByteBuffer.allocate(BLOCK_SIZE);
        paddedString.putShort(originalLength);
        paddedString.put(message);
        while(paddedString.hasRemaining()) {
            paddedString.put(padSymbol);
        }
        return paddedString.array();
    }

    public static byte[] getMainBlockBytes(byte[] paddedString) {
        int high = paddedString[0];
        int low = paddedString[1];
        int length = (high << 8) + low;

        //testing if it is only padding
        for (int i=length+2; i<paddedString.length-1; i++) {
            if(paddedString[i] != paddedString [i+1]) {
                System.out.println("not matching in padding for " + paddedString[i] + " and " + paddedString[i+1]);
            }
        }

        byte [] mainBlockBytes = new byte[length];
        for (int i=0; i<length; i++) {
            mainBlockBytes[i] = paddedString[i+2];
        }

        return mainBlockBytes;
    }

    public static void printSmpVersions(byte[] mainBlockBytes) {
        byte[] smpVersionBytes = new byte[]{mainBlockBytes[0], mainBlockBytes[1], mainBlockBytes[2], mainBlockBytes[3]};

        // Parse the bytes as two Word16 values (16-bit unsigned integers)
        ByteBuffer buffer = ByteBuffer.wrap(smpVersionBytes);
        int minVer = buffer.getShort() & 0xFFFF;  // Mask to treat as unsigned
        int maxVer = buffer.getShort() & 0xFFFF;

        System.out.println("SMP minVersion: " + minVer);
        System.out.println("SMP maxVersion: " + maxVer);
    }
}
